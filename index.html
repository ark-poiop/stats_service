<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ì›¹ê¸°ë°˜ í†µê³„ ë¶„ì„ íˆ´ (MVP)</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.7.0/dist/simple-statistics.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600&display=swap');
    
    :root {
      --primary-color: #2196F3;
      --secondary-color: #f5f5f5;
      --text-color: #333;
      --border-radius: 8px;
      --shadow: 0 2px 8px rgba(0,0,0,0.1);
      --header-height: 60px;
      --footer-height: 60px;
      --sidebar-width: 280px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Pretendard', sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: #f9f9f9;
      height: 100vh;
      display: grid;
      grid-template-areas:
        "header header"
        "sidebar main"
        "footer footer";
      grid-template-columns: var(--sidebar-width) 1fr;
      grid-template-rows: var(--header-height) 1fr var(--footer-height);
    }

    /* í—¤ë” ìŠ¤íƒ€ì¼ */
    .header {
      grid-area: header;
      background: white;
      padding: 0 2rem;
      display: flex;
      align-items: center;
      box-shadow: var(--shadow);
      z-index: 100;
    }

    .header h1 {
      font-size: 1.5rem;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* ì‚¬ì´ë“œë°” ìŠ¤íƒ€ì¼ */
    .sidebar {
      grid-area: sidebar;
      background: white;
      padding: 2rem;
      box-shadow: var(--shadow);
      overflow-y: auto;
    }

    .sidebar-menu {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* ë©”ì¸ ì»¨í…ì¸  ì˜ì—­ */
    .main {
      grid-area: main;
      padding: 2rem;
      overflow-y: auto;
    }

    /* í‘¸í„° ìŠ¤íƒ€ì¼ */
    .footer {
      grid-area: footer;
      background: white;
      padding: 1rem 2rem;
      text-align: center;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
    }

    .card {
      background: white;
      border-radius: var(--border-radius);
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
    }

    .button {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: var(--border-radius);
      background: var(--primary-color);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      width: 100%;
      margin-bottom: 0.5rem;
    }

    .button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);
    }

    .button-secondary {
      background: var(--secondary-color);
      color: var(--text-color);
    }

    .file-upload {
      border: 2px dashed #ddd;
      border-radius: var(--border-radius);
      padding: 2rem;
      text-align: center;
      margin: 1rem 0;
      cursor: pointer;
      transition: all 0.2s;
    }

    .file-upload:hover {
      border-color: var(--primary-color);
      background: #f8f9fa;
    }

    select {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      margin: 0.5rem 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }

    th, td {
      padding: 0.75rem;
      border: 1px solid #eee;
      text-align: left;
    }

    th {
      background: #f8f9fa;
      font-weight: 600;
    }

    .tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .tab {
      padding: 0.5rem 1rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: all 0.2s;
    }

    .tab.active {
      background: var(--primary-color);
      color: white;
    }

    #plotArea {
      width: 100%;
      height: 400px;
      margin: 1rem 0;
    }

    @media (max-width: 768px) {
      body {
        grid-template-areas:
          "header"
          "main"
          "footer";
        grid-template-columns: 1fr;
      }

      .sidebar {
        display: none;
      }

      .main {
        padding: 1rem;
      }
    }

    .export-section {
      margin-top: 2rem;
    }

    .export-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .export-buttons .button {
      width: auto;
      margin-bottom: 0;
    }

    @media (max-width: 768px) {
      .export-buttons {
        flex-direction: column;
      }
      
      .export-buttons .button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <!-- í—¤ë” -->
  <header class="header">
    <h1>ğŸ“Š í†µê³„ ë¶„ì„ ë„êµ¬</h1>
  </header>

  <!-- ì‚¬ì´ë“œë°” -->
  <aside class="sidebar">
    <div class="sidebar-menu">
      <h2>ğŸ“Œ ë°ì´í„° ì—…ë¡œë“œ</h2>
      <div class="file-upload" id="dropZone">
        <p>íŒŒì¼ì„ ë“œë˜ê·¸í•˜ì—¬ ì—…ë¡œë“œí•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</p>
        <input type="file" id="fileInput" accept=".csv,.xlsx" style="display: none;">
      </div>
      <button class="button" id="sampleDataBtn">ìƒ˜í”Œ ë°ì´í„°ë¡œ ì‹œì‘</button>

      <h2>âš™ï¸ ë¶„ì„ ì„¤ì •</h2>
      <select id="analysis-method">
        <option disabled selected>ë¶„ì„ ë°©ë²• ì„ íƒ</option>
        <optgroup label="ê¸°ìˆ í†µê³„">
          <option value="descriptive">ê¸°ì´ˆí†µê³„ëŸ‰ (í‰ê· , ì¤‘ì•™ê°’, ìµœë¹ˆê°’)</option>
          <option value="dispersion">ì‚°í¬ë„ (í‘œì¤€í¸ì°¨, ë¶„ì‚°, ë²”ìœ„)</option>
          <option value="distribution">ë¶„í¬ (ì‚¬ë¶„ìœ„ìˆ˜, ë¹„ëŒ€ì¹­ë„, ì²¨ë„)</option>
          <option value="frequency">ë„ìˆ˜ë¶„í¬í‘œ</option>
        </optgroup>
        <optgroup label="ì‹œê°í™”">
          <option value="histogram">íˆìŠ¤í† ê·¸ë¨</option>
          <option value="boxplot">ë°•ìŠ¤í”Œë¡¯</option>
          <option value="scatter">ì‚°ì ë„</option>
        </optgroup>
        <optgroup label="ê°€ì„¤ê²€ì •">
          <option value="ttest-ind">ë…ë¦½í‘œë³¸ t-ê²€ì •</option>
          <option value="ttest-paired">ëŒ€ì‘í‘œë³¸ t-ê²€ì •</option>
          <option value="anova-one">ì¼ì›ë¶„ì‚°ë¶„ì„</option>
          <option value="anova-two">ì´ì›ë¶„ì‚°ë¶„ì„</option>
          <option value="chi-square">ì¹´ì´ì œê³± ê²€ì •</option>
        </optgroup>
        <optgroup label="ìƒê´€ ë° íšŒê·€">
          <option value="correlation-pearson">í”¼ì–´ìŠ¨ ìƒê´€ë¶„ì„</option>
          <option value="correlation-spearman">ìŠ¤í”¼ì–´ë§Œ ìƒê´€ë¶„ì„</option>
          <option value="regression-simple">ë‹¨ìˆœ ì„ í˜• íšŒê·€</option>
          <option value="regression-multiple">ë‹¤ì¤‘ íšŒê·€</option>
          <option value="regression-logistic">ë¡œì§€ìŠ¤í‹± íšŒê·€</option>
        </optgroup>
        <optgroup label="ë¹„ëª¨ìˆ˜ ê²€ì •">
          <option value="mann-whitney">ë§¨íœ˜íŠ¸ë‹ˆ U ê²€ì •</option>
          <option value="wilcoxon">ìœŒì½•ìŠ¨ ë¶€í˜¸ ìˆœìœ„ ê²€ì •</option>
          <option value="kruskal-wallis">í¬ë£¨ìŠ¤ì¹¼-ì™ˆë¦¬ìŠ¤ ê²€ì •</option>
        </optgroup>
      </select>

      <div id="variable-selection">
        <select id="independent-variable">
          <option disabled selected>ë…ë¦½ë³€ìˆ˜ ì„ íƒ</option>
        </select>
        
        <select id="dependent-variable">
          <option disabled selected>ì¢…ì†ë³€ìˆ˜ ì„ íƒ</option>
        </select>

        <div id="additional-options" style="display: none;">
          <select id="grouping-variable">
            <option disabled selected>ê·¸ë£¹ ë³€ìˆ˜ ì„ íƒ</option>
          </select>
          
          <select id="additional-vars" multiple>
            <option disabled selected>ì¶”ê°€ ë³€ìˆ˜ ì„ íƒ (ë‹¤ì¤‘ ì„ íƒ ê°€ëŠ¥)</option>
          </select>
        </div>
      </div>
      
      <button class="button" onclick="runAnalysis()">ë¶„ì„ ì‹¤í–‰</button>
    </div>
  </aside>

  <!-- ë©”ì¸ ì»¨í…ì¸  -->
  <main class="main">
    <div class="card">
      <h2>ğŸ“‹ ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°</h2>
      <div style="overflow-x: auto;">
        <table id="previewTable">
          <thead></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>ğŸ“ˆ ë¶„ì„ ê²°ê³¼</h2>
      <div class="tabs">
        <div class="tab active" data-view="table">í‘œ</div>
        <div class="tab" data-view="plot">ê·¸ë˜í”„</div>
      </div>
      
      <div id="resultArea">
        <table id="resultTable">
          <thead></thead>
          <tbody></tbody>
        </table>
        <div id="plotArea"></div>
      </div>
    </div>

    <!-- ê²°ê³¼ ë‚´ë³´ë‚´ê¸° ì„¹ì…˜ -->
    <div class="card export-section">
      <h2>ğŸ“¥ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°</h2>
      <div class="export-buttons">
        <button class="button button-secondary" onclick="exportToCSV()">
          <span>ğŸ“Š CSV ë‹¤ìš´ë¡œë“œ</span>
        </button>
        <button class="button button-secondary" onclick="exportGraph()">
          <span>ğŸ“ˆ ê·¸ë˜í”„ ë‹¤ìš´ë¡œë“œ (PNG)</span>
        </button>
        <button class="button" onclick="exportToPDF()">
          <span>ğŸ“„ PDF ë³´ê³ ì„œ ìƒì„±</span>
        </button>
      </div>
    </div>

    <script>
      // ê²°ê³¼ ë‚´ë³´ë‚´ê¸° í•¨ìˆ˜ë“¤
      function exportToCSV() {
        const table = document.getElementById('resultTable');
        const rows = Array.from(table.querySelectorAll('tr'));
        
        // CSV ë°ì´í„° ìƒì„±
        const csvData = rows.map(row => 
          Array.from(row.querySelectorAll('th,td'))
            .map(cell => `"${cell.textContent}"`)
            .join(',')
        ).join('\n');
        
        // CSV íŒŒì¼ ë‹¤ìš´ë¡œë“œ
        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'ë¶„ì„ê²°ê³¼.csv';
        link.click();
      }

      function exportGraph() {
        const plotArea = document.getElementById('plotArea');
        
        // Plotly ê·¸ë˜í”„ë¥¼ PNG ì´ë¯¸ì§€ë¡œ ë³€í™˜
        Plotly.toImage(plotArea, {
          format: 'png',
          width: 800,
          height: 600
        }).then(function(dataUrl) {
          // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
          const link = document.createElement('a');
          link.href = dataUrl;
          link.download = 'ë¶„ì„ê·¸ë˜í”„.png';
          link.click();
        });
      }

      function exportToPDF() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        // ì œëª© ì¶”ê°€
        doc.setFontSize(16);
        doc.text('í†µê³„ ë¶„ì„ ë³´ê³ ì„œ', 20, 20);
        doc.setFontSize(12);
        
        // ë¶„ì„ ì •ë³´ ì¶”ê°€
        const analysisType = document.getElementById('analysis-method').value;
        const xVar = document.getElementById('independent-variable').value;
        const yVar = document.getElementById('dependent-variable').value;
        doc.text(`ë¶„ì„ ìœ í˜•: ${analysisType}`, 20, 30);
        doc.text(`X ë³€ìˆ˜: ${xVar}`, 20, 40);
        doc.text(`Y ë³€ìˆ˜: ${yVar}`, 20, 50);
        
        // ê²°ê³¼ í…Œì´ë¸” ì¶”ê°€
        const table = document.getElementById('resultTable');
        const rows = Array.from(table.querySelectorAll('tr'));
        let yPos = 70;
        
        rows.forEach((row, rowIndex) => {
          const cells = Array.from(row.querySelectorAll('th,td'));
          let xPos = 20;
          
          cells.forEach(cell => {
            doc.text(cell.textContent, xPos, yPos);
            xPos += 40;
          });
          
          yPos += 10;
          
          // í˜ì´ì§€ ë„˜ê¹€ ì²˜ë¦¬
          if (yPos > 280) {
            doc.addPage();
            yPos = 20;
          }
        });
        
        // ê·¸ë˜í”„ ì¶”ê°€
        const plotArea = document.getElementById('plotArea');
        Plotly.toImage(plotArea, {
          format: 'png',
          width: 800,
          height: 600
        }).then(function(dataUrl) {
          // ì´ë¯¸ì§€ë¥¼ PDFì— ì¶”ê°€
          const img = new Image();
          img.src = dataUrl;
          img.onload = function() {
            doc.addPage();
            doc.addImage(img, 'PNG', 20, 20, 170, 170);
            doc.save('ë¶„ì„ë³´ê³ ì„œ.pdf');
          };
        });
      }

      // ë‚´ë³´ë‚´ê¸° ìœ í˜•ì— ë”°ë¥¸ ì˜µì…˜ í‘œì‹œ/ìˆ¨ê¹€
      document.getElementById('export-type').addEventListener('change', function() {
        const graphTypeSelect = document.getElementById('graph-type');
        graphTypeSelect.style.display = this.value === 'graph' ? 'block' : 'none';
      });
    </script>
  </main>

  <!-- í‘¸í„° -->
  <footer class="footer">
    <p>Â© 2024 í†µê³„ ë¶„ì„ ë„êµ¬ | ë¬¸ì˜: support@stats-tool.com</p>
  </footer>

  <script>
    let uploadedData = [];
    let currentView = 'table';

    // íŒŒì¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥
    const dropZone = document.getElementById('dropZone');
    
    dropZone.addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#2196F3';
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#ddd';
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#ddd';
      const files = e.dataTransfer.files;
      if (files.length) handleFile(files[0]);
    });

    document.getElementById('fileInput').addEventListener('change', function(e) {
      if (e.target.files.length) handleFile(e.target.files[0]);
    });

    function handleFile(file) {
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
          uploadedData = results.data;
          renderPreviewTable(results.meta.fields, results.data);
          populateVariableSelectors(results.meta.fields);
        }
      });
    }

    function renderPreviewTable(fields, data) {
      const thead = document.querySelector('#previewTable thead');
      const tbody = document.querySelector('#previewTable tbody');
      thead.innerHTML = '<tr>' + fields.map(f => `<th>${f}</th>`).join('') + '</tr>';
      tbody.innerHTML = data.slice(0, 5).map(row => {
        return '<tr>' + fields.map(f => `<td>${row[f]}</td>`).join('') + '</tr>';
      }).join('');
    }

    function populateVariableSelectors(fields) {
      const indep = document.getElementById('independent-variable');
      const dep = document.getElementById('dependent-variable');
      const options = fields.map(f => `<option value="${f}">${f}</option>`).join('');
      indep.innerHTML = '<option disabled selected>ë…ë¦½ë³€ìˆ˜ ì„ íƒ</option>' + options;
      dep.innerHTML = '<option disabled selected>ì¢…ì†ë³€ìˆ˜ ì„ íƒ</option>' + options;
    }

    function runAnalysis() {
      const method = document.getElementById('analysis-method').value;
      const y = document.getElementById('dependent-variable').value;
      const x = document.getElementById('independent-variable').value;
      
      if (!method || !y || !x) {
        alert('í•„ìˆ˜ ë¶„ì„ ì˜µì…˜ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
        return;
      }

      const yData = uploadedData.map(row => parseFloat(row[y])).filter(v => !isNaN(v));
      const xData = uploadedData.map(row => parseFloat(row[x])).filter(v => !isNaN(v));

      if (yData.length === 0 || xData.length === 0) {
        alert('ìœ íš¨í•œ ìˆ˜ì¹˜í˜• ë°ì´í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
        return;
      }

      // ë¶„ì„ ë°©ë²•ì— ë”°ë¥¸ í•¨ìˆ˜ í˜¸ì¶œ
      switch (method) {
        // ê¸°ìˆ í†µê³„
        case 'descriptive':
          showDescriptiveStats(x, y, xData, yData);
          break;
        case 'dispersion':
          showDispersionStats(x, y, xData, yData);
          break;
        case 'distribution':
          showDistributionStats(x, y, xData, yData);
          break;
        case 'frequency':
          showFrequencyTable(x, y, xData, yData);
          break;

        // ì‹œê°í™”
        case 'histogram':
          showHistogram(x, y, xData, yData);
          break;
        case 'boxplot':
          showBoxPlot(x, y, xData, yData);
          break;
        case 'scatter':
          showScatterPlot(x, y, xData, yData);
          break;

        // ê°€ì„¤ê²€ì •
        case 'ttest-ind':
          performIndependentTTest(x, y, xData, yData);
          break;
        case 'ttest-paired':
          performPairedTTest(x, y, xData, yData);
          break;
        case 'anova-one':
          performOneWayANOVA(x, y, xData, yData);
          break;
        case 'chi-square':
          performChiSquareTest(x, y, xData, yData);
          break;

        // ìƒê´€ ë° íšŒê·€
        case 'correlation-pearson':
          showPearsonCorrelation(x, y, xData, yData);
          break;
        case 'correlation-spearman':
          showSpearmanCorrelation(x, y, xData, yData);
          break;
        case 'regression-simple':
          performSimpleRegression(x, y, xData, yData);
          break;
        case 'regression-multiple':
          performMultipleRegression(x, y, xData, yData);
          break;

        // ë¹„ëª¨ìˆ˜ ê²€ì •
        case 'mann-whitney':
          performMannWhitneyTest(x, y, xData, yData);
          break;
        case 'wilcoxon':
          performWilcoxonTest(x, y, xData, yData);
          break;
        case 'kruskal-wallis':
          performKruskalWallisTest(x, y, xData, yData);
          break;
      }
    }

    // ê¸°ìˆ í†µê³„ í•¨ìˆ˜ë“¤
    function showDescriptiveStats(xLabel, yLabel, xData, yData) {
      const xStats = calculateDescriptiveStats(xData);
      const yStats = calculateDescriptiveStats(yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë³€ìˆ˜</th>
          <th>í‰ê· </th>
          <th>ì¤‘ì•™ê°’</th>
          <th>ìµœë¹ˆê°’</th>
          <th>í‘œì¤€í¸ì°¨</th>
          <th>ìµœì†Œê°’</th>
          <th>ìµœëŒ€ê°’</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>${xLabel}</td>
          <td>${xStats.mean}</td>
          <td>${xStats.median}</td>
          <td>${xStats.mode}</td>
          <td>${xStats.std}</td>
          <td>${xStats.min}</td>
          <td>${xStats.max}</td>
        </tr>
        <tr>
          <td>${yLabel}</td>
          <td>${yStats.mean}</td>
          <td>${yStats.median}</td>
          <td>${yStats.mode}</td>
          <td>${yStats.std}</td>
          <td>${yStats.min}</td>
          <td>${yStats.max}</td>
        </tr>
      `;

      // íˆìŠ¤í† ê·¸ë¨ ì‹œê°í™”
      showHistogram(xLabel, yLabel, xData, yData);
    }

    function calculateDescriptiveStats(data) {
      return {
        mean: ss.mean(data).toFixed(2),
        median: ss.median(data).toFixed(2),
        mode: ss.mode(data).toFixed(2),
        std: ss.standardDeviation(data).toFixed(2),
        variance: ss.variance(data).toFixed(2),
        min: Math.min(...data).toFixed(2),
        max: Math.max(...data).toFixed(2),
        q1: ss.quantile(data, 0.25).toFixed(2),
        q3: ss.quantile(data, 0.75).toFixed(2),
        skewness: ss.sampleSkewness(data).toFixed(2),
        kurtosis: ss.sampleKurtosis(data).toFixed(2)
      };
    }

    // ì‚°í¬ë„ ë¶„ì„
    function showDispersionStats(xLabel, yLabel, xData, yData) {
      const xStats = calculateDispersionStats(xData);
      const yStats = calculateDispersionStats(yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë³€ìˆ˜</th>
          <th>í‘œì¤€í¸ì°¨</th>
          <th>ë¶„ì‚°</th>
          <th>ë²”ìœ„</th>
          <th>ì‚¬ë¶„ìœ„ìˆ˜ ë²”ìœ„</th>
          <th>ë³€ë™ê³„ìˆ˜</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>${xLabel}</td>
          <td>${xStats.std}</td>
          <td>${xStats.variance}</td>
          <td>${xStats.range}</td>
          <td>${xStats.iqr}</td>
          <td>${xStats.cv}%</td>
        </tr>
        <tr>
          <td>${yLabel}</td>
          <td>${yStats.std}</td>
          <td>${yStats.variance}</td>
          <td>${yStats.range}</td>
          <td>${yStats.iqr}</td>
          <td>${yStats.cv}%</td>
        </tr>
      `;

      // ë°•ìŠ¤í”Œë¡¯ìœ¼ë¡œ ì‹œê°í™”
      showBoxPlot(xLabel, yLabel, xData, yData);
    }

    function calculateDispersionStats(data) {
      const mean = ss.mean(data);
      const std = ss.standardDeviation(data);
      const q1 = ss.quantile(data, 0.25);
      const q3 = ss.quantile(data, 0.75);
      
      return {
        std: std.toFixed(2),
        variance: ss.variance(data).toFixed(2),
        range: (Math.max(...data) - Math.min(...data)).toFixed(2),
        iqr: (q3 - q1).toFixed(2),
        cv: ((std / mean) * 100).toFixed(2)
      };
    }

    // ë¶„í¬ ë¶„ì„
    function showDistributionStats(xLabel, yLabel, xData, yData) {
      const xStats = calculateDistributionStats(xData);
      const yStats = calculateDistributionStats(yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë³€ìˆ˜</th>
          <th>ì œ1ì‚¬ë¶„ìœ„ìˆ˜</th>
          <th>ì œ2ì‚¬ë¶„ìœ„ìˆ˜</th>
          <th>ì œ3ì‚¬ë¶„ìœ„ìˆ˜</th>
          <th>ë¹„ëŒ€ì¹­ë„</th>
          <th>ì²¨ë„</th>
          <th>ì •ê·œì„±</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>${xLabel}</td>
          <td>${xStats.q1}</td>
          <td>${xStats.q2}</td>
          <td>${xStats.q3}</td>
          <td>${xStats.skewness}</td>
          <td>${xStats.kurtosis}</td>
          <td>${xStats.normality}</td>
        </tr>
        <tr>
          <td>${yLabel}</td>
          <td>${yStats.q1}</td>
          <td>${yStats.q2}</td>
          <td>${yStats.q3}</td>
          <td>${yStats.skewness}</td>
          <td>${yStats.kurtosis}</td>
          <td>${yStats.normality}</td>
        </tr>
      `;

      // QQí”Œë¡¯ìœ¼ë¡œ ì‹œê°í™”
      showQQPlot(xLabel, yLabel, xData, yData);
    }

    function calculateDistributionStats(data) {
      const skewness = ss.sampleSkewness(data);
      const kurtosis = ss.sampleKurtosis(data);
      
      return {
        q1: ss.quantile(data, 0.25).toFixed(2),
        q2: ss.quantile(data, 0.50).toFixed(2),
        q3: ss.quantile(data, 0.75).toFixed(2),
        skewness: skewness.toFixed(2),
        kurtosis: kurtosis.toFixed(2),
        normality: interpretNormality(skewness, kurtosis)
      };
    }

    function interpretNormality(skewness, kurtosis) {
      const skewThreshold = 0.5;
      const kurtThreshold = 0.5;
      
      if (Math.abs(skewness) < skewThreshold && Math.abs(kurtosis) < kurtThreshold) {
        return 'ì •ê·œë¶„í¬ì— ê°€ê¹Œì›€';
      } else if (Math.abs(skewness) < skewThreshold) {
        return 'ë¹„ëŒ€ì¹­ë„ëŠ” ì •ìƒì´ë‚˜ ì²¨ë„ì— ì°¨ì´ ìˆìŒ';
      } else if (Math.abs(kurtosis) < kurtThreshold) {
        return 'ì²¨ë„ëŠ” ì •ìƒì´ë‚˜ ë¹„ëŒ€ì¹­ë„ì— ì°¨ì´ ìˆìŒ';
      }
      return 'ì •ê·œë¶„í¬ì™€ ì°¨ì´ ìˆìŒ';
    }

    // ë„ìˆ˜ë¶„í¬í‘œ
    function showFrequencyTable(xLabel, yLabel, xData, yData) {
      const xFreq = calculateFrequencyTable(xData);
      const yFreq = calculateFrequencyTable(yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë³€ìˆ˜</th>
          <th>êµ¬ê°„</th>
          <th>ë„ìˆ˜</th>
          <th>ìƒëŒ€ë„ìˆ˜</th>
          <th>ëˆ„ì ë„ìˆ˜</th>
          <th>ëˆ„ì ìƒëŒ€ë„ìˆ˜</th>
        </tr>
      `;
      
      tbody.innerHTML = xFreq.intervals.map((interval, i) => `
        <tr>
          <td>${i === 0 ? xLabel : ''}</td>
          <td>${interval}</td>
          <td>${xFreq.frequencies[i]}</td>
          <td>${xFreq.relativeFreq[i]}%</td>
          <td>${xFreq.cumulativeFreq[i]}</td>
          <td>${xFreq.cumulativeRelFreq[i]}%</td>
        </tr>
      `).join('') + yFreq.intervals.map((interval, i) => `
        <tr>
          <td>${i === 0 ? yLabel : ''}</td>
          <td>${interval}</td>
          <td>${yFreq.frequencies[i]}</td>
          <td>${yFreq.relativeFreq[i]}%</td>
          <td>${yFreq.cumulativeFreq[i]}</td>
          <td>${yFreq.cumulativeRelFreq[i]}%</td>
        </tr>
      `).join('');

      // íˆìŠ¤í† ê·¸ë¨ê³¼ ëˆ„ì ë¶„í¬ ì‹œê°í™”
      showFrequencyPlot(xLabel, yLabel, xFreq, yFreq);
    }

    function calculateFrequencyTable(data) {
      const min = Math.min(...data);
      const max = Math.max(...data);
      const range = max - min;
      const binCount = Math.ceil(Math.sqrt(data.length)); // Sturges' formula
      const binWidth = range / binCount;
      
      const intervals = [];
      const frequencies = new Array(binCount).fill(0);
      
      // êµ¬ê°„ ì„¤ì •
      for (let i = 0; i < binCount; i++) {
        const start = min + (i * binWidth);
        const end = start + binWidth;
        intervals.push(`${start.toFixed(1)} - ${end.toFixed(1)}`);
      }
      
      // ë„ìˆ˜ ê³„ì‚°
      data.forEach(value => {
        const binIndex = Math.min(Math.floor((value - min) / binWidth), binCount - 1);
        frequencies[binIndex]++;
      });
      
      // ìƒëŒ€ë„ìˆ˜ì™€ ëˆ„ì ë„ìˆ˜ ê³„ì‚°
      const relativeFreq = frequencies.map(f => ((f / data.length) * 100).toFixed(1));
      const cumulativeFreq = frequencies.reduce((acc, f) => {
        acc.push((acc.length ? acc[acc.length - 1] : 0) + f);
        return acc;
      }, []);
      const cumulativeRelFreq = cumulativeFreq.map(f => ((f / data.length) * 100).toFixed(1));
      
      return {
        intervals,
        frequencies,
        relativeFreq,
        cumulativeFreq,
        cumulativeRelFreq
      };
    }

    function showFrequencyPlot(xLabel, yLabel, xFreq, yFreq) {
      const trace1 = {
        x: xFreq.intervals,
        y: xFreq.frequencies,
        type: 'bar',
        name: `${xLabel} ë„ìˆ˜`,
        opacity: 0.7
      };

      const trace2 = {
        x: xFreq.intervals,
        y: xFreq.cumulativeFreq,
        type: 'scatter',
        mode: 'lines+markers',
        name: `${xLabel} ëˆ„ì ë„ìˆ˜`,
        yaxis: 'y2'
      };

      const layout = {
        title: 'ë„ìˆ˜ë¶„í¬ ë° ëˆ„ì ë¶„í¬',
        barmode: 'overlay',
        xaxis: { title: 'êµ¬ê°„' },
        yaxis: { title: 'ë„ìˆ˜' },
        yaxis2: {
          title: 'ëˆ„ì ë„ìˆ˜',
          overlaying: 'y',
          side: 'right'
        }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    // QQí”Œë¡¯ ì‹œê°í™”
    function showQQPlot(xLabel, yLabel, xData, yData) {
      const xSorted = [...xData].sort((a, b) => a - b);
      const ySorted = [...yData].sort((a, b) => a - b);
      const n = xSorted.length;
      
      const theoreticalQuantiles = xSorted.map((_, i) => 
        ss.probit((i + 0.5) / n)
      );

      const trace1 = {
        x: theoreticalQuantiles,
        y: xSorted,
        mode: 'markers',
        name: xLabel,
        type: 'scatter'
      };

      const trace2 = {
        x: theoreticalQuantiles,
        y: ySorted,
        mode: 'markers',
        name: yLabel,
        type: 'scatter'
      };

      const layout = {
        title: 'Q-Q Plot (ì •ê·œì„± ê²€ì •)',
        xaxis: { title: 'ì´ë¡ ì  ë¶„ìœ„ìˆ˜' },
        yaxis: { title: 'ê´€ì¸¡ëœ ë¶„ìœ„ìˆ˜' }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    // ì‹œê°í™” í•¨ìˆ˜ë“¤
    function showHistogram(xLabel, yLabel, xData, yData) {
      const trace1 = {
        x: xData,
        type: 'histogram',
        name: xLabel,
        opacity: 0.7
      };

      const trace2 = {
        x: yData,
        type: 'histogram',
        name: yLabel,
        opacity: 0.7
      };

      const layout = {
        title: 'ë³€ìˆ˜ë³„ ë¶„í¬',
        barmode: 'overlay',
        xaxis: { title: 'ê°’' },
        yaxis: { title: 'ë¹ˆë„' }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    function showBoxPlot(xLabel, yLabel, xData, yData) {
      const trace1 = {
        y: xData,
        type: 'box',
        name: xLabel
      };

      const trace2 = {
        y: yData,
        type: 'box',
        name: yLabel
      };

      const layout = {
        title: 'ë°•ìŠ¤í”Œë¡¯',
        yaxis: { title: 'ê°’' }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    // ìƒê´€ë¶„ì„ í•¨ìˆ˜
    function showPearsonCorrelation(xLabel, yLabel, xData, yData) {
      const correlation = ss.sampleCorrelation(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë¶„ì„ ìœ í˜•</th>
          <th>ë³€ìˆ˜ X</th>
          <th>ë³€ìˆ˜ Y</th>
          <th>ìƒê´€ê³„ìˆ˜</th>
          <th>í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>í”¼ì–´ìŠ¨ ìƒê´€ë¶„ì„</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${correlation.toFixed(3)}</td>
          <td>${interpretCorrelation(correlation)}</td>
        </tr>
      `;

      // ì‚°ì ë„ ì‹œê°í™”
      showScatterPlot(xLabel, yLabel, xData, yData, correlation);
    }

    function showScatterPlot(xLabel, yLabel, xData, yData, correlation = null) {
      const trace = {
        x: xData,
        y: yData,
        mode: 'markers',
        type: 'scatter',
        name: 'ë°ì´í„° í¬ì¸íŠ¸'
      };

      const layout = {
        title: correlation ? 
          `ì‚°ì ë„ (ìƒê´€ê³„ìˆ˜: ${correlation.toFixed(3)})` : 
          'ì‚°ì ë„',
        xaxis: { title: xLabel },
        yaxis: { title: yLabel }
      };

      Plotly.newPlot('plotArea', [trace], layout);
    }

    function interpretCorrelation(correlation) {
      const abs = Math.abs(correlation);
      if (abs >= 0.9) return 'ë§¤ìš° ê°•í•œ ìƒê´€ê´€ê³„';
      if (abs >= 0.7) return 'ê°•í•œ ìƒê´€ê´€ê³„';
      if (abs >= 0.5) return 'ì¤‘ê°„ ì •ë„ì˜ ìƒê´€ê´€ê³„';
      if (abs >= 0.3) return 'ì•½í•œ ìƒê´€ê´€ê³„';
      return 'ë§¤ìš° ì•½í•œ ìƒê´€ê´€ê³„';
    }

    // íƒ­ ì „í™˜
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentView = tab.dataset.view;
        
        if (currentView === 'table') {
          document.getElementById('resultTable').style.display = 'table';
          document.getElementById('plotArea').style.display = 'none';
        } else {
          document.getElementById('resultTable').style.display = 'none';
          document.getElementById('plotArea').style.display = 'block';
        }
      });
    });

    // ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ
    document.getElementById('sampleDataBtn').addEventListener('click', () => {
      const sampleData = [
        { height: 170, weight: 65, age: 25 },
        { height: 175, weight: 70, age: 30 },
        { height: 160, weight: 55, age: 28 },
        { height: 180, weight: 80, age: 35 },
        { height: 165, weight: 60, age: 27 }
      ];
      
      uploadedData = sampleData;
      renderPreviewTable(Object.keys(sampleData[0]), sampleData);
      populateVariableSelectors(Object.keys(sampleData[0]));
    });

    // ê°€ì„¤ê²€ì • í•¨ìˆ˜ë“¤
    function performIndependentTTest(xLabel, yLabel, xData, yData) {
      const { t, pValue } = calculateTTest(xData, yData);
      const cohensD = calculateCohensD(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ê²€ì • ìœ í˜•</th>
          <th>ê·¸ë£¹ 1</th>
          <th>ê·¸ë£¹ 2</th>
          <th>t-í†µê³„ëŸ‰</th>
          <th>p-ê°’</th>
          <th>íš¨ê³¼ í¬ê¸°(Cohen's d)</th>
          <th>ê²°ê³¼ í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>ë…ë¦½í‘œë³¸ t-ê²€ì •</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${t.toFixed(3)}</td>
          <td>${pValue.toFixed(4)}</td>
          <td>${cohensD.toFixed(3)}</td>
          <td>${interpretTTest(pValue, cohensD)}</td>
        </tr>
      `;

      // ë°•ìŠ¤í”Œë¡¯ìœ¼ë¡œ ì‹œê°í™”
      showBoxPlot(xLabel, yLabel, xData, yData);
    }

    function calculateTTest(group1, group2) {
      const n1 = group1.length;
      const n2 = group2.length;
      const mean1 = ss.mean(group1);
      const mean2 = ss.mean(group2);
      const var1 = ss.variance(group1);
      const var2 = ss.variance(group2);
      
      // Welch's t-test
      const t = (mean1 - mean2) / Math.sqrt((var1/n1) + (var2/n2));
      const df = Math.floor(Math.pow((var1/n1 + var2/n2), 2) / 
                 (Math.pow(var1/n1, 2)/(n1-1) + Math.pow(var2/n2, 2)/(n2-1)));
      
      // p-value ê³„ì‚° (ì–‘ì¸¡ê²€ì •)
      const pValue = 2 * (1 - ss.tDistribution.cdf(Math.abs(t), df));
      
      return { t, pValue };
    }

    function calculateCohensD(group1, group2) {
      const mean1 = ss.mean(group1);
      const mean2 = ss.mean(group2);
      const pooledStd = Math.sqrt(
        ((group1.length - 1) * ss.variance(group1) + 
         (group2.length - 1) * ss.variance(group2)) / 
        (group1.length + group2.length - 2)
      );
      
      return Math.abs(mean1 - mean2) / pooledStd;
    }

    function interpretTTest(pValue, effectSize) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.001)';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.01)';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨ (p < 0.05)';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ (p â‰¥ 0.05)';
      
      let effect = '';
      if (effectSize >= 0.8) effect = 'í° íš¨ê³¼ í¬ê¸°';
      else if (effectSize >= 0.5) effect = 'ì¤‘ê°„ íš¨ê³¼ í¬ê¸°';
      else effect = 'ì‘ì€ íš¨ê³¼ í¬ê¸°';
      
      return `${significance}, ${effect}`;
    }

    // íšŒê·€ë¶„ì„ í•¨ìˆ˜ë“¤
    function performSimpleRegression(xLabel, yLabel, xData, yData) {
      const regression = calculateRegression(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë¶„ì„ ìœ í˜•</th>
          <th>ë…ë¦½ë³€ìˆ˜</th>
          <th>ì¢…ì†ë³€ìˆ˜</th>
          <th>ì ˆí¸(Î²â‚€)</th>
          <th>ê¸°ìš¸ê¸°(Î²â‚)</th>
          <th>RÂ²</th>
          <th>p-ê°’</th>
          <th>í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>ë‹¨ìˆœì„ í˜•íšŒê·€</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${regression.intercept.toFixed(3)}</td>
          <td>${regression.slope.toFixed(3)}</td>
          <td>${regression.r2.toFixed(3)}</td>
          <td>${regression.pValue.toFixed(4)}</td>
          <td>${interpretRegression(regression)}</td>
        </tr>
      `;

      // íšŒê·€ì„ ì´ í¬í•¨ëœ ì‚°ì ë„ ì‹œê°í™”
      showRegressionPlot(xLabel, yLabel, xData, yData, regression);
    }

    function calculateRegression(x, y) {
      const n = x.length;
      const sumX = ss.sum(x);
      const sumY = ss.sum(y);
      const sumXY = x.reduce((acc, xi, i) => acc + xi * y[i], 0);
      const sumX2 = x.reduce((acc, xi) => acc + xi * xi, 0);
      
      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      
      // RÂ² ê³„ì‚°
      const yPred = x.map(xi => slope * xi + intercept);
      const yMean = ss.mean(y);
      const ssRes = y.reduce((acc, yi, i) => acc + Math.pow(yi - yPred[i], 2), 0);
      const ssTot = y.reduce((acc, yi) => acc + Math.pow(yi - yMean, 2), 0);
      const r2 = 1 - (ssRes / ssTot);
      
      // F-í†µê³„ëŸ‰ê³¼ p-ê°’ ê³„ì‚°
      const dfReg = 1;
      const dfRes = n - 2;
      const msReg = (ssTot - ssRes) / dfReg;
      const msRes = ssRes / dfRes;
      const fStat = msReg / msRes;
      const pValue = 1 - ss.fDistribution.cdf(fStat, dfReg, dfRes);
      
      return { slope, intercept, r2, pValue };
    }

    function showRegressionPlot(xLabel, yLabel, xData, yData, regression) {
      const trace1 = {
        x: xData,
        y: yData,
        mode: 'markers',
        type: 'scatter',
        name: 'ë°ì´í„° í¬ì¸íŠ¸'
      };

      // íšŒê·€ì„  ìƒì„±
      const xRange = [Math.min(...xData), Math.max(...xData)];
      const yPred = xRange.map(x => regression.slope * x + regression.intercept);
      
      const trace2 = {
        x: xRange,
        y: yPred,
        mode: 'lines',
        type: 'scatter',
        name: 'íšŒê·€ì„ ',
        line: { color: 'red' }
      };

      const layout = {
        title: `ë‹¨ìˆœì„ í˜•íšŒê·€ (RÂ² = ${regression.r2.toFixed(3)})`,
        xaxis: { title: xLabel },
        yaxis: { title: yLabel }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    function interpretRegression(regression) {
      let significance = '';
      if (regression.pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„±';
      else if (regression.pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„±';
      else if (regression.pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ';
      
      let fit = '';
      if (regression.r2 >= 0.7) fit = 'ê°•í•œ ì„¤ëª…ë ¥';
      else if (regression.r2 >= 0.5) fit = 'ì¤‘ê°„ ì •ë„ì˜ ì„¤ëª…ë ¥';
      else fit = 'ì•½í•œ ì„¤ëª…ë ¥';
      
      return `${significance}, ${fit} (RÂ² = ${regression.r2.toFixed(3)})`;
    }

    // ë¹„ëª¨ìˆ˜ ê²€ì • í•¨ìˆ˜ë“¤
    function performMannWhitneyTest(xLabel, yLabel, xData, yData) {
      const { u, pValue } = calculateMannWhitneyTest(xData, yData);
      const effectSize = calculateEffectSize(u, xData.length, yData.length);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ê²€ì • ìœ í˜•</th>
          <th>ê·¸ë£¹ 1</th>
          <th>ê·¸ë£¹ 2</th>
          <th>U í†µê³„ëŸ‰</th>
          <th>p-ê°’</th>
          <th>íš¨ê³¼ í¬ê¸°(r)</th>
          <th>ê²°ê³¼ í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>ë§¨íœ˜íŠ¸ë‹ˆ U ê²€ì •</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${u.toFixed(3)}</td>
          <td>${pValue.toFixed(4)}</td>
          <td>${effectSize.toFixed(3)}</td>
          <td>${interpretMannWhitney(pValue, effectSize)}</td>
        </tr>
      `;

      // ë°•ìŠ¤í”Œë¡¯ìœ¼ë¡œ ì‹œê°í™”
      showBoxPlot(xLabel, yLabel, xData, yData);
    }

    function calculateMannWhitneyTest(group1, group2) {
      const n1 = group1.length;
      const n2 = group2.length;
      
      // ìˆœìœ„ ê³„ì‚°
      const allData = [...group1, ...group2];
      const ranks = calculateRanks(allData);
      
      // ê° ê·¸ë£¹ì˜ ìˆœìœ„ í•© ê³„ì‚°
      const r1 = ranks.slice(0, n1).reduce((a, b) => a + b, 0);
      const r2 = ranks.slice(n1).reduce((a, b) => a + b, 0);
      
      // U í†µê³„ëŸ‰ ê³„ì‚°
      const u1 = r1 - (n1 * (n1 + 1)) / 2;
      const u2 = r2 - (n2 * (n2 + 1)) / 2;
      const u = Math.min(u1, u2);
      
      // p-ê°’ ê³„ì‚° (ê·¼ì‚¬ì  ì •ê·œë¶„í¬ ì‚¬ìš©)
      const mu = (n1 * n2) / 2;
      const sigma = Math.sqrt((n1 * n2 * (n1 + n2 + 1)) / 12);
      const z = (u - mu) / sigma;
      const pValue = 2 * (1 - ss.standardNormal.cdf(Math.abs(z)));
      
      return { u, pValue };
    }

    function calculateEffectSize(u, n1, n2) {
      return Math.abs(u - (n1 * n2) / 2) / Math.sqrt(n1 * n2 * (n1 + n2 + 1) / 12);
    }

    function interpretMannWhitney(pValue, effectSize) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.001)';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.01)';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨ (p < 0.05)';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ (p â‰¥ 0.05)';
      
      let effect = '';
      if (effectSize >= 0.5) effect = 'í° íš¨ê³¼ í¬ê¸°';
      else if (effectSize >= 0.3) effect = 'ì¤‘ê°„ íš¨ê³¼ í¬ê¸°';
      else effect = 'ì‘ì€ íš¨ê³¼ í¬ê¸°';
      
      return `${significance}, ${effect}`;
    }

    // ANOVA í•¨ìˆ˜ë“¤
    function performOneWayANOVA(xLabel, yLabel, xData, yData) {
      const { f, pValue, etaSquared } = calculateOneWayANOVA(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ê²€ì • ìœ í˜•</th>
          <th>ê·¸ë£¹ ë³€ìˆ˜</th>
          <th>ì¢…ì† ë³€ìˆ˜</th>
          <th>F í†µê³„ëŸ‰</th>
          <th>p-ê°’</th>
          <th>Î·Â² (ì—íƒ€ì œê³±)</th>
          <th>ê²°ê³¼ í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>ì¼ì›ë¶„ì‚°ë¶„ì„</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${f.toFixed(3)}</td>
          <td>${pValue.toFixed(4)}</td>
          <td>${etaSquared.toFixed(3)}</td>
          <td>${interpretANOVA(pValue, etaSquared)}</td>
        </tr>
      `;

      // ë°•ìŠ¤í”Œë¡¯ìœ¼ë¡œ ì‹œê°í™”
      showBoxPlot(xLabel, yLabel, xData, yData);
    }

    function calculateOneWayANOVA(group1, group2) {
      const n1 = group1.length;
      const n2 = group2.length;
      const n = n1 + n2;
      
      // ì „ì²´ í‰ê· 
      const grandMean = ss.mean([...group1, ...group2]);
      
      // ê·¸ë£¹ í‰ê· 
      const mean1 = ss.mean(group1);
      const mean2 = ss.mean(group2);
      
      // ì œê³±í•© ê³„ì‚°
      const ssBetween = n1 * Math.pow(mean1 - grandMean, 2) + 
                       n2 * Math.pow(mean2 - grandMean, 2);
      const ssWithin = group1.reduce((acc, x) => acc + Math.pow(x - mean1, 2), 0) +
                      group2.reduce((acc, x) => acc + Math.pow(x - mean2, 2), 0);
      const ssTotal = ssBetween + ssWithin;
      
      // ììœ ë„ ê³„ì‚°
      const dfBetween = 1; // 2ê°œ ê·¸ë£¹ì´ë¯€ë¡œ
      const dfWithin = n - 2;
      
      // í‰ê· ì œê³± ê³„ì‚°
      const msBetween = ssBetween / dfBetween;
      const msWithin = ssWithin / dfWithin;
      
      // F í†µê³„ëŸ‰ê³¼ p-ê°’ ê³„ì‚°
      const f = msBetween / msWithin;
      const pValue = 1 - ss.fDistribution.cdf(f, dfBetween, dfWithin);
      
      // ì—íƒ€ì œê³± ê³„ì‚°
      const etaSquared = ssBetween / ssTotal;
      
      return { f, pValue, etaSquared };
    }

    function interpretANOVA(pValue, etaSquared) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.001)';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.01)';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨ (p < 0.05)';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ (p â‰¥ 0.05)';
      
      let effect = '';
      if (etaSquared >= 0.14) effect = 'í° íš¨ê³¼ í¬ê¸°';
      else if (etaSquared >= 0.06) effect = 'ì¤‘ê°„ íš¨ê³¼ í¬ê¸°';
      else effect = 'ì‘ì€ íš¨ê³¼ í¬ê¸°';
      
      return `${significance}, ${effect}`;
    }

    // ìˆœìœ„ ê³„ì‚° í—¬í¼ í•¨ìˆ˜
    function calculateRanks(data) {
      const sorted = [...data].sort((a, b) => a - b);
      const ranks = new Array(data.length);
      
      for (let i = 0; i < data.length; i++) {
        const value = data[i];
        const rank = sorted.indexOf(value) + 1;
        
        // ë™ì  ì²˜ë¦¬
        let ties = 0;
        for (let j = 0; j < i; j++) {
          if (data[j] === value) ties++;
        }
        
        ranks[i] = rank + ties;
      }
      
      return ranks;
    }

    // ì¹´ì´ì œê³± ê²€ì • í•¨ìˆ˜ë“¤
    function performChiSquareTest(xLabel, yLabel, xData, yData) {
      const { chiSquare, pValue, cramerV } = calculateChiSquareTest(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ê²€ì • ìœ í˜•</th>
          <th>ë³€ìˆ˜ X</th>
          <th>ë³€ìˆ˜ Y</th>
          <th>Ï‡Â² í†µê³„ëŸ‰</th>
          <th>p-ê°’</th>
          <th>Cramer's V</th>
          <th>ê²°ê³¼ í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>ì¹´ì´ì œê³± ê²€ì •</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${chiSquare.toFixed(3)}</td>
          <td>${pValue.toFixed(4)}</td>
          <td>${cramerV.toFixed(3)}</td>
          <td>${interpretChiSquare(pValue, cramerV)}</td>
        </tr>
      `;

      // ë§‰ëŒ€ ê·¸ë˜í”„ë¡œ ì‹œê°í™”
      showChiSquarePlot(xLabel, yLabel, xData, yData);
    }

    function calculateChiSquareTest(xData, yData) {
      // ë°ì´í„°ë¥¼ ë²”ì£¼í™”
      const xCategories = [...new Set(xData)];
      const yCategories = [...new Set(yData)];
      
      // êµì°¨í‘œ ìƒì„±
      const contingencyTable = Array(xCategories.length).fill().map(() => 
        Array(yCategories.length).fill(0)
      );
      
      // ë¹ˆë„ ê³„ì‚°
      xData.forEach((x, i) => {
        const xIndex = xCategories.indexOf(x);
        const yIndex = yCategories.indexOf(yData[i]);
        contingencyTable[xIndex][yIndex]++;
      });
      
      // ê¸°ëŒ€ë¹ˆë„ ê³„ì‚°
      const rowSums = contingencyTable.map(row => row.reduce((a, b) => a + b, 0));
      const colSums = contingencyTable[0].map((_, i) => 
        contingencyTable.reduce((a, row) => a + row[i], 0)
      );
      const total = rowSums.reduce((a, b) => a + b, 0);
      
      const expected = contingencyTable.map((row, i) => 
        row.map((_, j) => (rowSums[i] * colSums[j]) / total)
      );
      
      // ì¹´ì´ì œê³± í†µê³„ëŸ‰ ê³„ì‚°
      const chiSquare = contingencyTable.reduce((acc, row, i) => 
        acc + row.reduce((sum, cell, j) => 
          sum + Math.pow(cell - expected[i][j], 2) / expected[i][j], 0
        ), 0
      );
      
      // ììœ ë„ ê³„ì‚°
      const df = (xCategories.length - 1) * (yCategories.length - 1);
      
      // p-ê°’ ê³„ì‚°
      const pValue = 1 - ss.chiSquaredGoodnessOfFit.cdf(chiSquare, df);
      
      // Cramer's V ê³„ì‚°
      const cramerV = Math.sqrt(chiSquare / (total * (Math.min(xCategories.length, yCategories.length) - 1)));
      
      return { chiSquare, pValue, cramerV, contingencyTable, xCategories, yCategories };
    }

    function showChiSquarePlot(xLabel, yLabel, xData, yData) {
      const { contingencyTable, xCategories, yCategories } = calculateChiSquareTest(xData, yData);
      
      const traces = xCategories.map((x, i) => ({
        x: yCategories,
        y: contingencyTable[i],
        type: 'bar',
        name: x
      }));

      const layout = {
        title: 'êµì°¨ë¶„í¬',
        barmode: 'group',
        xaxis: { title: yLabel },
        yaxis: { title: 'ë¹ˆë„' }
      };

      Plotly.newPlot('plotArea', traces, layout);
    }

    function interpretChiSquare(pValue, cramerV) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.001)';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.01)';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨ (p < 0.05)';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ (p â‰¥ 0.05)';
      
      let effect = '';
      if (cramerV >= 0.5) effect = 'ê°•í•œ ì—°ê´€ì„±';
      else if (cramerV >= 0.3) effect = 'ì¤‘ê°„ ì •ë„ì˜ ì—°ê´€ì„±';
      else effect = 'ì•½í•œ ì—°ê´€ì„±';
      
      return `${significance}, ${effect}`;
    }

    // ë¡œì§€ìŠ¤í‹± íšŒê·€ ë¶„ì„ í•¨ìˆ˜ë“¤
    function performLogisticRegression(xLabel, yLabel, xData, yData) {
      const { coefficients, oddsRatios, pValues, pseudoR2 } = calculateLogisticRegression(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë¶„ì„ ìœ í˜•</th>
          <th>ë³€ìˆ˜</th>
          <th>íšŒê·€ê³„ìˆ˜</th>
          <th>ì˜¤ì¦ˆë¹„</th>
          <th>p-ê°’</th>
          <th>í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td rowspan="2">ë¡œì§€ìŠ¤í‹± íšŒê·€</td>
          <td>ì ˆí¸</td>
          <td>${coefficients[0].toFixed(3)}</td>
          <td>-</td>
          <td>${pValues[0].toFixed(4)}</td>
          <td>${interpretLogisticCoefficient(coefficients[0], pValues[0])}</td>
        </tr>
        <tr>
          <td>${xLabel}</td>
          <td>${coefficients[1].toFixed(3)}</td>
          <td>${oddsRatios[1].toFixed(3)}</td>
          <td>${pValues[1].toFixed(4)}</td>
          <td>${interpretLogisticCoefficient(coefficients[1], pValues[1])}</td>
        </tr>
      `;

      // ë¡œì§€ìŠ¤í‹± íšŒê·€ì„ ì´ í¬í•¨ëœ ì‚°ì ë„ ì‹œê°í™”
      showLogisticRegressionPlot(xLabel, yLabel, xData, yData, coefficients);
    }

    function calculateLogisticRegression(x, y) {
      // ìµœëŒ€ìš°ë„ ì¶”ì •ì„ ìœ„í•œ ë°˜ë³µì  ì¬ê°€ì¤‘ ìµœì†Œì œê³±ë²•
      let beta = [0, 0]; // ì´ˆê¸°ê°’
      const maxIter = 100;
      const tolerance = 1e-6;
      
      for (let iter = 0; iter < maxIter; iter++) {
        // ì˜ˆì¸¡ í™•ë¥  ê³„ì‚°
        const p = x.map(xi => 1 / (1 + Math.exp(-(beta[0] + beta[1] * xi))));
        
        // ê°€ì¤‘ì¹˜ì™€ ì‘ì—…ë³€ìˆ˜ ê³„ì‚°
        const w = p.map(pi => pi * (1 - pi));
        const z = x.map((xi, i) => beta[0] + beta[1] * xi + (y[i] - p[i]) / w[i]);
        
        // ê°€ì¤‘ ìµœì†Œì œê³± ì¶”ì •
        const xMatrix = x.map(xi => [1, xi]);
        const wMatrix = w.map(wi => [wi, 0, 0, wi]);
        
        const newBeta = solveWeightedLeastSquares(xMatrix, wMatrix, z);
        
        // ìˆ˜ë ´ í™•ì¸
        if (Math.abs(newBeta[0] - beta[0]) < tolerance && 
            Math.abs(newBeta[1] - beta[1]) < tolerance) {
          beta = newBeta;
          break;
        }
        
        beta = newBeta;
      }
      
      // ì˜¤ì¦ˆë¹„ ê³„ì‚°
      const oddsRatios = [Math.exp(beta[0]), Math.exp(beta[1])];
      
      // p-ê°’ ê³„ì‚° (Wald ê²€ì •)
      const pValues = calculateWaldTest(x, y, beta);
      
      // ì˜ì‚¬ RÂ² ê³„ì‚° (McFadden's RÂ²)
      const pseudoR2 = calculatePseudoR2(x, y, beta);
      
      return { coefficients: beta, oddsRatios, pValues, pseudoR2 };
    }

    function solveWeightedLeastSquares(xMatrix, wMatrix, z) {
      // ê°€ì¤‘ ìµœì†Œì œê³± ì¶”ì • êµ¬í˜„
      // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìˆ˜ì¹˜ì  ë°©ë²•ì„ ì‚¬ìš©í•´ì•¼ í•¨
      return [0, 0]; // ì„ì‹œ ë°˜í™˜ê°’
    }

    function calculateWaldTest(x, y, beta) {
      // Wald ê²€ì • í†µê³„ëŸ‰ ê³„ì‚°
      // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í‘œì¤€ì˜¤ì°¨ ê³„ì‚°ì´ í•„ìš”
      return [0.05, 0.05]; // ì„ì‹œ ë°˜í™˜ê°’
    }

    function calculatePseudoR2(x, y, beta) {
      // McFadden's RÂ² ê³„ì‚°
      // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë¡œê·¸ìš°ë„ ê³„ì‚°ì´ í•„ìš”
      return 0.5; // ì„ì‹œ ë°˜í™˜ê°’
    }

    function showLogisticRegressionPlot(xLabel, yLabel, xData, yData, coefficients) {
      const trace1 = {
        x: xData,
        y: yData,
        mode: 'markers',
        type: 'scatter',
        name: 'ë°ì´í„° í¬ì¸íŠ¸'
      };

      // ë¡œì§€ìŠ¤í‹± íšŒê·€ì„  ìƒì„±
      const xRange = [Math.min(...xData), Math.max(...xData)];
      const yPred = xRange.map(x => 
        1 / (1 + Math.exp(-(coefficients[0] + coefficients[1] * x)))
      );
      
      const trace2 = {
        x: xRange,
        y: yPred,
        mode: 'lines',
        type: 'scatter',
        name: 'ë¡œì§€ìŠ¤í‹± íšŒê·€ì„ ',
        line: { color: 'red' }
      };

      const layout = {
        title: 'ë¡œì§€ìŠ¤í‹± íšŒê·€ ë¶„ì„',
        xaxis: { title: xLabel },
        yaxis: { title: 'í™•ë¥ ' }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    function interpretLogisticCoefficient(coef, pValue) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„±';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„±';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ';
      
      let direction = coef > 0 ? 'ì–‘ì˜' : 'ìŒì˜';
      let effect = Math.abs(coef) >= 1 ? 'ê°•í•œ' : Math.abs(coef) >= 0.5 ? 'ì¤‘ê°„ ì •ë„ì˜' : 'ì•½í•œ';
      
      return `${significance}, ${direction} ${effect} íš¨ê³¼`;
    }

    // ìŠ¤í”¼ì–´ë§Œ ìƒê´€ ë¶„ì„ í•¨ìˆ˜ë“¤
    function showSpearmanCorrelation(xLabel, yLabel, xData, yData) {
      const { correlation, pValue } = calculateSpearmanCorrelation(xData, yData);
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë¶„ì„ ìœ í˜•</th>
          <th>ë³€ìˆ˜ X</th>
          <th>ë³€ìˆ˜ Y</th>
          <th>ìƒê´€ê³„ìˆ˜</th>
          <th>p-ê°’</th>
          <th>í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td>ìŠ¤í”¼ì–´ë§Œ ìƒê´€ë¶„ì„</td>
          <td>${xLabel}</td>
          <td>${yLabel}</td>
          <td>${correlation.toFixed(3)}</td>
          <td>${pValue.toFixed(4)}</td>
          <td>${interpretSpearmanCorrelation(correlation, pValue)}</td>
        </tr>
      `;

      // ì‚°ì ë„ ì‹œê°í™”
      showScatterPlot(xLabel, yLabel, xData, yData, correlation);
    }

    function calculateSpearmanCorrelation(x, y) {
      // ìˆœìœ„ ê³„ì‚°
      const xRanks = calculateRanks(x);
      const yRanks = calculateRanks(y);
      
      // ìˆœìœ„ ì°¨ì´ì˜ ì œê³± í•© ê³„ì‚°
      const dSquared = xRanks.reduce((sum, rank, i) => 
        sum + Math.pow(rank - yRanks[i], 2), 0
      );
      
      const n = x.length;
      const correlation = 1 - (6 * dSquared) / (n * (n * n - 1));
      
      // p-ê°’ ê³„ì‚° (ê·¼ì‚¬ì  ì •ê·œë¶„í¬ ì‚¬ìš©)
      const z = correlation * Math.sqrt((n - 2) / (1 - correlation * correlation));
      const pValue = 2 * (1 - ss.standardNormal.cdf(Math.abs(z)));
      
      return { correlation, pValue };
    }

    function interpretSpearmanCorrelation(correlation, pValue) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.001)';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„± (p < 0.01)';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨ (p < 0.05)';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ (p â‰¥ 0.05)';
      
      const abs = Math.abs(correlation);
      let strength = '';
      if (abs >= 0.9) strength = 'ë§¤ìš° ê°•í•œ';
      else if (abs >= 0.7) strength = 'ê°•í•œ';
      else if (abs >= 0.5) strength = 'ì¤‘ê°„ ì •ë„ì˜';
      else if (abs >= 0.3) strength = 'ì•½í•œ';
      else strength = 'ë§¤ìš° ì•½í•œ';
      
      let direction = correlation > 0 ? 'ì–‘ì˜' : 'ìŒì˜';
      
      return `${significance}, ${direction} ${strength} ìƒê´€ê´€ê³„`;
    }

    // ë‹¤ì¤‘ íšŒê·€ ë¶„ì„ í•¨ìˆ˜ë“¤
    function performMultipleRegression(xLabel, yLabel, xData, yData) {
      const additionalVars = Array.from(document.getElementById('additional-vars').selectedOptions)
        .map(option => option.value);
      
      if (additionalVars.length === 0) {
        alert('ì¶”ê°€ ë³€ìˆ˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
        return;
      }

      const { coefficients, r2, pValues, fStat, fPValue } = calculateMultipleRegression(
        xData, yData, additionalVars
      );
      
      const thead = document.querySelector('#resultTable thead');
      const tbody = document.querySelector('#resultTable tbody');
      
      thead.innerHTML = `
        <tr>
          <th>ë¶„ì„ ìœ í˜•</th>
          <th>ë³€ìˆ˜</th>
          <th>íšŒê·€ê³„ìˆ˜</th>
          <th>í‘œì¤€í™” ê³„ìˆ˜</th>
          <th>p-ê°’</th>
          <th>í•´ì„</th>
        </tr>
      `;
      
      tbody.innerHTML = `
        <tr>
          <td rowspan="${coefficients.length}">ë‹¤ì¤‘ íšŒê·€</td>
          <td>ì ˆí¸</td>
          <td>${coefficients[0].toFixed(3)}</td>
          <td>-</td>
          <td>${pValues[0].toFixed(4)}</td>
          <td>${interpretMultipleRegression(coefficients[0], pValues[0])}</td>
        </tr>
        ${coefficients.slice(1).map((coef, i) => `
          <tr>
            <td>${i === 0 ? xLabel : additionalVars[i-1]}</td>
            <td>${coef.toFixed(3)}</td>
            <td>${(coef * Math.sqrt(ss.variance(xData)) / Math.sqrt(ss.variance(yData))).toFixed(3)}</td>
            <td>${pValues[i+1].toFixed(4)}</td>
            <td>${interpretMultipleRegression(coef, pValues[i+1])}</td>
          </tr>
        `).join('')}
      `;

      // ëª¨ë¸ ì í•©ë„ ì •ë³´ ì¶”ê°€
      const modelInfo = document.createElement('div');
      modelInfo.innerHTML = `
        <p>ëª¨ë¸ ì í•©ë„: RÂ² = ${r2.toFixed(3)}</p>
        <p>F í†µê³„ëŸ‰ = ${fStat.toFixed(3)}, p-ê°’ = ${fPValue.toFixed(4)}</p>
      `;
      document.getElementById('resultArea').insertBefore(modelInfo, document.getElementById('resultTable'));

      // íšŒê·€ì„ ì´ í¬í•¨ëœ ì‚°ì ë„ ì‹œê°í™”
      showMultipleRegressionPlot(xLabel, yLabel, xData, yData, coefficients, additionalVars);
    }

    function calculateMultipleRegression(x, y, additionalVars) {
      const n = x.length;
      const k = additionalVars.length + 1; // ë…ë¦½ë³€ìˆ˜ ê°œìˆ˜
      
      // ë°ì´í„° í–‰ë ¬ êµ¬ì„±
      const X = x.map((xi, i) => {
        const row = [1, xi];
        additionalVars.forEach(varName => {
          row.push(parseFloat(uploadedData[i][varName]));
        });
        return row;
      });
      
      // ìµœì†Œì œê³± ì¶”ì •
      const Xt = transposeMatrix(X);
      const XtX = matrixMultiply(Xt, X);
      const XtXInv = matrixInverse(XtX);
      const Xty = matrixMultiply(Xt, y);
      const coefficients = matrixMultiply(XtXInv, Xty);
      
      // RÂ² ê³„ì‚°
      const yPred = X.map(row => 
        row.reduce((sum, xi, i) => sum + xi * coefficients[i], 0)
      );
      const yMean = ss.mean(y);
      const ssRes = y.reduce((acc, yi, i) => acc + Math.pow(yi - yPred[i], 2), 0);
      const ssTot = y.reduce((acc, yi) => acc + Math.pow(yi - yMean, 2), 0);
      const r2 = 1 - (ssRes / ssTot);
      
      // F í†µê³„ëŸ‰ê³¼ p-ê°’ ê³„ì‚°
      const dfReg = k - 1;
      const dfRes = n - k;
      const msReg = (ssTot - ssRes) / dfReg;
      const msRes = ssRes / dfRes;
      const fStat = msReg / msRes;
      const fPValue = 1 - ss.fDistribution.cdf(fStat, dfReg, dfRes);
      
      // ê° ê³„ìˆ˜ì˜ p-ê°’ ê³„ì‚°
      const pValues = coefficients.map((coef, i) => {
        const se = Math.sqrt(msRes * XtXInv[i][i]);
        const t = coef / se;
        return 2 * (1 - ss.tDistribution.cdf(Math.abs(t), dfRes));
      });
      
      return { coefficients, r2, pValues, fStat, fPValue };
    }

    function showMultipleRegressionPlot(xLabel, yLabel, xData, yData, coefficients, additionalVars) {
      const trace1 = {
        x: xData,
        y: yData,
        mode: 'markers',
        type: 'scatter',
        name: 'ë°ì´í„° í¬ì¸íŠ¸'
      };

      // ì˜ˆì¸¡ê°’ ê³„ì‚°
      const xRange = [Math.min(...xData), Math.max(...xData)];
      const yPred = xRange.map(x => {
        const row = [1, x];
        additionalVars.forEach(varName => {
          row.push(ss.mean(uploadedData.map(row => parseFloat(row[varName]))));
        });
        return row.reduce((sum, xi, i) => sum + xi * coefficients[i], 0);
      });
      
      const trace2 = {
        x: xRange,
        y: yPred,
        mode: 'lines',
        type: 'scatter',
        name: 'íšŒê·€ì„ ',
        line: { color: 'red' }
      };

      const layout = {
        title: `ë‹¤ì¤‘ íšŒê·€ ë¶„ì„ (RÂ² = ${coefficients.r2.toFixed(3)})`,
        xaxis: { title: xLabel },
        yaxis: { title: yLabel }
      };

      Plotly.newPlot('plotArea', [trace1, trace2], layout);
    }

    function interpretMultipleRegression(coef, pValue) {
      let significance = '';
      if (pValue < 0.001) significance = 'ë§¤ìš° ê°•í•œ í†µê³„ì  ìœ ì˜ì„±';
      else if (pValue < 0.01) significance = 'ê°•í•œ í†µê³„ì  ìœ ì˜ì„±';
      else if (pValue < 0.05) significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•¨';
      else significance = 'í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•˜ì§€ ì•ŠìŒ';
      
      let direction = coef > 0 ? 'ì–‘ì˜' : 'ìŒì˜';
      let effect = Math.abs(coef) >= 1 ? 'ê°•í•œ' : Math.abs(coef) >= 0.5 ? 'ì¤‘ê°„ ì •ë„ì˜' : 'ì•½í•œ';
      
      return `${significance}, ${direction} ${effect} íš¨ê³¼`;
    }

    // í–‰ë ¬ ì—°ì‚° í—¬í¼ í•¨ìˆ˜ë“¤
    function transposeMatrix(matrix) {
      return matrix[0].map((_, i) => matrix.map(row => row[i]));
    }

    function matrixMultiply(a, b) {
      if (typeof b[0] === 'number') {
        return a.map(row => row.reduce((sum, ai, i) => sum + ai * b[i], 0));
      }
      return a.map(row => 
        b[0].map((_, j) => row.reduce((sum, ai, i) => sum + ai * b[i][j], 0))
      );
    }

    function matrixInverse(matrix) {
      // ê°€ìš°ìŠ¤-ì¡°ë¥´ë‹¨ ì†Œê±°ë²•ì„ ì‚¬ìš©í•œ ì—­í–‰ë ¬ ê³„ì‚°
      const n = matrix.length;
      const augmented = matrix.map((row, i) => {
        const identity = new Array(n).fill(0);
        identity[i] = 1;
        return [...row, ...identity];
      });
      
      // ì „ì§„ ì†Œê±°
      for (let i = 0; i < n; i++) {
        const pivot = augmented[i][i];
        for (let j = 0; j < 2 * n; j++) {
          augmented[i][j] /= pivot;
        }
        
        for (let k = 0; k < n; k++) {
          if (k !== i) {
            const factor = augmented[k][i];
            for (let j = 0; j < 2 * n; j++) {
              augmented[k][j] -= factor * augmented[i][j];
            }
          }
        }
      }
      
      // ì—­í–‰ë ¬ ë¶€ë¶„ ì¶”ì¶œ
      return augmented.map(row => row.slice(n));
    }

    // íˆíŠ¸ë§µ í•¨ìˆ˜ë“¤
    function showHeatmap(xLabel, yLabel, xData, yData) {
      const { matrix, xLabels, yLabels } = calculateHeatmapMatrix(xData, yData);
      
      const trace = {
        z: matrix,
        x: xLabels,
        y: yLabels,
        type: 'heatmap',
        colorscale: 'Viridis',
        colorbar: {
          title: 'ë¹ˆë„'
        }
      };

      const layout = {
        title: 'íˆíŠ¸ë§µ',
        xaxis: { title: xLabel },
        yaxis: { title: yLabel }
      };

      Plotly.newPlot('plotArea', [trace], layout);
    }

    function calculateHeatmapMatrix(x, y) {
      // êµ¬ê°„ ì„¤ì • (ìŠ¤í„°ì§€ìŠ¤ ê·œì¹™ ì‚¬ìš©)
      const xBins = Math.ceil(Math.log2(x.length) + 1);
      const yBins = Math.ceil(Math.log2(y.length) + 1);
      
      // êµ¬ê°„ ê²½ê³„ ê³„ì‚°
      const xMin = Math.min(...x);
      const xMax = Math.max(...x);
      const yMin = Math.min(...y);
      const yMax = Math.max(...y);
      
      const xStep = (xMax - xMin) / xBins;
      const yStep = (yMax - yMin) / yBins;
      
      // ë¹ˆë„ í–‰ë ¬ ì´ˆê¸°í™”
      const matrix = Array(yBins).fill().map(() => Array(xBins).fill(0));
      
      // ë°ì´í„° í¬ì¸íŠ¸ ë¶„ë¥˜
      x.forEach((xi, i) => {
        const xIndex = Math.min(Math.floor((xi - xMin) / xStep), xBins - 1);
        const yIndex = Math.min(Math.floor((y[i] - yMin) / yStep), yBins - 1);
        matrix[yIndex][xIndex]++;
      });
      
      // ë ˆì´ë¸” ìƒì„±
      const xLabels = Array(xBins).fill().map((_, i) => 
        `${(xMin + i * xStep).toFixed(1)}-${(xMin + (i + 1) * xStep).toFixed(1)}`
      );
      const yLabels = Array(yBins).fill().map((_, i) => 
        `${(yMin + i * yStep).toFixed(1)}-${(yMin + (i + 1) * yStep).toFixed(1)}`
      );
      
      return { matrix, xLabels, yLabels };
    }

    // ì‹œê³„ì—´ ê·¸ë˜í”„ í•¨ìˆ˜ë“¤
    function showTimeSeries(xLabel, yLabel, xData, yData) {
      // ë‚ ì§œ í˜•ì‹ ë³€í™˜
      const dates = xData.map(dateStr => new Date(dateStr));
      
      const trace = {
        x: dates,
        y: yData,
        type: 'scatter',
        mode: 'lines+markers',
        name: yLabel
      };

      const layout = {
        title: 'ì‹œê³„ì—´ ê·¸ë˜í”„',
        xaxis: { 
          title: xLabel,
          type: 'date',
          tickformat: '%Y-%m-%d'
        },
        yaxis: { title: yLabel },
        hovermode: 'x unified'
      };

      Plotly.newPlot('plotArea', [trace], layout);
    }

    function showTimeSeriesWithTrend(xLabel, yLabel, xData, yData) {
      const dates = xData.map(dateStr => new Date(dateStr));
      
      // ì¶”ì„¸ì„  ê³„ì‚°
      const { slope, intercept } = calculateTrendLine(dates, yData);
      const trendLine = dates.map(date => 
        slope * (date - dates[0]) / (24 * 60 * 60 * 1000) + intercept
      );
      
      const traces = [
        {
          x: dates,
          y: yData,
          type: 'scatter',
          mode: 'lines+markers',
          name: 'ì‹¤ì œ ë°ì´í„°'
        },
        {
          x: dates,
          y: trendLine,
          type: 'scatter',
          mode: 'lines',
          name: 'ì¶”ì„¸ì„ ',
          line: { color: 'red', dash: 'dash' }
        }
      ];

      const layout = {
        title: 'ì‹œê³„ì—´ ê·¸ë˜í”„ (ì¶”ì„¸ì„  í¬í•¨)',
        xaxis: { 
          title: xLabel,
          type: 'date',
          tickformat: '%Y-%m-%d'
        },
        yaxis: { title: yLabel },
        hovermode: 'x unified'
      };

      Plotly.newPlot('plotArea', traces, layout);
    }

    function calculateTrendLine(x, y) {
      const n = x.length;
      const xMean = x.reduce((sum, xi) => sum + xi, 0) / n;
      const yMean = y.reduce((sum, yi) => sum + yi, 0) / n;
      
      let numerator = 0;
      let denominator = 0;
      
      for (let i = 0; i < n; i++) {
        const xDiff = x[i] - xMean;
        numerator += xDiff * (y[i] - yMean);
        denominator += xDiff * xDiff;
      }
      
      const slope = numerator / denominator;
      const intercept = yMean - slope * xMean;
      
      return { slope, intercept };
    }

    // ë¶„ì„ í•¨ìˆ˜ì— ìƒˆë¡œìš´ ì‹œê°í™” ì˜µì…˜ ì¶”ê°€
    function performAnalysis() {
      const analysisType = document.getElementById('analysis-type').value;
      const xVar = document.getElementById('x-var').value;
      const yVar = document.getElementById('y-var').value;
      
      if (!xVar || !yVar) {
        alert('ë³€ìˆ˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
        return;
      }
      
      const xData = uploadedData.map(row => parseFloat(row[xVar]));
      const yData = uploadedData.map(row => parseFloat(row[yVar]));
      
      switch(analysisType) {
        // ... existing cases ...
        
        case 'heatmap':
          showHeatmap(xVar, yVar, xData, yData);
          break;
          
        case 'time-series':
          showTimeSeries(xVar, yVar, xData, yData);
          break;
          
        case 'time-series-trend':
          showTimeSeriesWithTrend(xVar, yVar, xData, yData);
          break;
      }
    }

    // HTMLì— í•„ìš”í•œ ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
    document.head.appendChild(script);
  </script>
</body>
</html>
